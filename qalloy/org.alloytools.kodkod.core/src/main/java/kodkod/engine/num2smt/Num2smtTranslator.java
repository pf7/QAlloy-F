package kodkod.engine.num2smt;

import kodkod.engine.bool.*;
import kodkod.engine.bool.ITEGate;
import kodkod.engine.config.QuantitativeOptions;
import kodkod.engine.num.*;
import kodkod.util.ints.IntSet;
import kodkod.util.ints.IntTreeSet;

import java.util.*;
import java.util.stream.Collectors;

import static kodkod.engine.bool.Operator.*;
import static kodkod.engine.config.QuantitativeOptions.QuantitativeType.INTEGER;

/**
 * Transforms quantitative problem into a SMT problem as a SMT-LIB2 specification, with certain characteristics:
 * - each function symbol has a unique identifier between fs of the same sort
 * - the specification produced will be composed exclusively by numeric and boolean function symbols,
 * following a naming convention such that, if a boolean fs X and a numeric fs B have the same identifier,
 * then the boolean fs represents the numeric fs from the boolean pov, i.e., B(i) = X(i) != 0
 * - Numeric fs may or may not be bounded by a {@code limit}. In case such limit exists, numeric fs representing
 * primary variables of the main problem and those created by default may be assigned a value that does not exceed
 * such limit during the solving process. However, fs representing some intermediate result, etc.., declared as "free"
 * are always unbounded.
 * - Logic = QF_NIA for Integer problems
 *         = QF_NRA for Fuzzy problems
 * - Numeric function symbols will either be integer or real depending on the logic at hand.
 *
 * @specfield assertion_stack : Stack
 * @specfield options : QuantitativeOptions
 * @specfield limit : Integer
 *  limit = null => unbounded numeric fs
 * @specfield numFS : [Integer, String]
 * numFS associates the identifiers of the numeric fs to its variable name.
 */
public class Num2smtTranslator implements BooleanVisitor<Integer,Object>, NumericVisitor<Integer, Object> {

    // Options to take into account during the generation of the specification
    private final QuantitativeOptions options;
    // Logic to be used
    protected final String logic;
    // SMT Solver options that preface the assertion stack, generated by default,
    // according to the specified solving options.
    // Its support may vary from solver to solver.
    protected final String smt2options;
    // Assertion Stack
    private final Stack<String> assertion_stack;
    // Visited NumericValues and Gates
    protected final IntSet visited;
    // Visited BooleanValues and Gates
    protected final IntSet visitedBV;
    // Binary values that occur in the Circuit being processed
    private final Map<Integer, BinaryValue> binaryValues;

    // Kind of numeric function symbols
    private final String type;
    // Numeric Function Symbols declared
    protected final Map<Integer, String> numFS;
    // Boolean Function Symbols declared
    private final Map<Integer, String> boolFS;
    // Maximum value that bounded integer fs can take (null iff all integer fs are unbounded)
    private final Integer CAP;
    // Number of assertions in the stack at a given point in time
    private int numberOfAssertions;

    protected Num2smtTranslator(QuantitativeOptions options, String logic) {
        this.options = options;
        this.assertion_stack = new Stack<>();
        this.visited = new IntTreeSet();
        this.visitedBV = new IntTreeSet();
        this.logic = logic == null ? "QF_NIA" : logic;
        this.type = this.logic.equals("QF_NIA") ? "Int" : "Real";
        StringBuilder smtOptions = new StringBuilder();
        smtOptions.append("(set-logic ").append(this.logic).append(")\n");
        smtOptions.append("(set-option :produce-models true)\n");
        if(options.incremental())
            smtOptions.append("(set-option :incremental true)\n");
        this.smt2options = smtOptions.toString();
        /*assertion_stack.push("(set-logic " + logic + ")");
        assertion_stack.push("(set-option :produce-models true)");
        if(options.incremental())
            assertion_stack.push("(set-option :incremental true)");
        //assertion_stack.push("(set-option :produce-assertions true)");
        //assertion_stack.push("(set-option :produce-unsat-cores true)");*/
        this.numFS = new HashMap<>();
        this.boolFS = new HashMap<>();
        this.binaryValues = new HashMap<>();
        this.CAP = options.getMaximumWeight();
        this.numberOfAssertions = 0;
    }

    /**
     * @return The number of function symbols in the current state of the assertion stack.
     */
    public int getNumberOfVariables(){ return this.numFS.size() + this.boolFS.size(); }

    /*
     * @return The number of assertions in the current state of the assertion stack.
     */
    public int getNumberOfAssertions(){
        return this.numberOfAssertions;
    }

    /**
     * @return Current state of the assertion stack, without solving commands.
     */
    public String getOptionlessSpecification(){
        return String.join("\n", assertion_stack);
    }

    /**
     * @return Current state of the assertion stack.
     */
    public String getSpecification(){
        return this.smt2options + String.join("\n", assertion_stack);
    }

    /**
     * Creates a new assertion stack containing the corresponding SMT representation of the given problem.
     * @param problem Collection of boolean formulas potentially containing (quantitative) constraints
     *                over {@link NumericMatrix numeric matrices}.
     * @param options quantitative solving options
     * @return SMTSolver over the specification generated
     */
    public static SMTSolver translate(final Collection<BooleanFormula> problem, QuantitativeOptions options){
        final Num2smtTranslator translator = new Num2smtTranslator(options, options.getAnalysisType() == INTEGER ? "QF_NIA" : "QF_NRA");
        final String smt2 = translator.translateProblem(problem).getOptionlessSpecification();
        final SMTSpecification spec = new SMTSpecification(translator.logic,
                                                           translator.smt2options,
                                                           smt2,
                                                           translator.numFS,
                                                           translator.getNumberOfVariables(),
                                                           translator.numberOfAssertions,
                                                           options);

        switch(options.solver()){
            case CVC4:
                return new CVC4Solver(spec);
            case MathSAT:
                return new MathSAT(spec);
            case Yices:
                return new Yices(spec);
            default: // Z3
                return new Z3Solver(spec);
        }
    }

    /**
     * Trivial outcome translation TODO: CVC4 -> Selected SMT Solver
     */
    public static CVC4Solver translate(final BooleanConstant result) {
        SMTSpecification trivialSpecification = new SMTSpecification(
          null,
          null,
          null,
          new HashMap<>(),
          0,
          0,
          new QuantitativeOptions(INTEGER)
        );
        return new CVC4Solver(trivialSpecification, result.booleanValue());
    }

    /**
     * Applies this translator to the given circuit, building the specification,
     * and returns the translator.
     * @param problem Collection of boolean formulas potentially containing (quantitative) constraints
     *                over {@link NumericMatrix numeric matrices}.
     * @return this
     */
    protected Num2smtTranslator translateProblem(Collection<BooleanFormula> problem) {
        for(BooleanFormula f : problem)
            f.accept(this, null);
        for(BooleanFormula f : problem)
            addAssertion(getFormula(f.label()));

        return this;
    }

    /**
     * Declares a function symbol {@code var} of sort {@code type}.
     */
    protected void declare(String type, String var){
        assertion_stack.push(String.format("(declare-const %s %s)", var, type));
    }

    /**
     * Adds the assertion to the stack.
     */
    protected void addAssertion(String a){
        assertion_stack.push(String.format("(assert %s)", a));
        numberOfAssertions++;
    }

    /**
     * Declares a numeric function symbol {@code var} with identifier {@code id}, s.t.,
     * minValue <= var <= maxValue
     * The bound represented by minValue/maxValue is imposed only if it isn't null.
     *
     * @param minValue minimum value of var
     * @param maxValue maximum value of var
     * @param extend If extend = true and there already is a numeric fs declared with
     *               the given {@code id}, adds the new constraints to the assertion stack.
     *               If extend = false, there will be no changes to the current state
     *               of the assertion stack.
     * @return function symbol
     */
    protected String addVariable(int id, String var, Integer minValue, Integer maxValue, boolean extend){
        // Declaration
        if(numFS.containsKey(id))
            var = numFS.get(id);
        else declare(this.type, var);

        if(!numFS.containsKey(id) || extend){
            numFS.put(id, var);

            // Properties
            if(minValue != null)
                addAssertion(range(">=", var, minValue));
            if(maxValue != null)
                addAssertion(range("<=", var, maxValue));

            // Relation with existent boolean counterpart
            if(boolFS.containsKey(id))
                addAssertion(String.format("(= %s (not (= %s 0)))", boolFS.get(id), var));
        }

        return var;
    }

    /**
     * Introduces a new unbound numeric variable.
     */
    protected String addFreeVariable(int v){
        return addVariable(v, "f" + v, null, null, false);
    }

    /**
     * Obtain the numeric variable with the given label.
     * If there is none, a new unbound numeric variable will be created, according to the logic at hand.
     */
    private String getNumeric(int v){
        if(!numFS.containsKey(v) && binaryValues.containsKey(v)){
            NumericValue nv = binaryValues.get(v).toNumeric();
            switch (nv.getClass().getSimpleName()){ // TODO arg
                case "NumericVariable":
                    this.visit((NumericVariable)nv, null);
                    break;
                case "ITEGate":
                    this.visit((kodkod.engine.num.ITEGate)nv, null);
                    break;
                default: // TODO
                    throw new IllegalArgumentException("getNumeric BinaryValue of kind = " + nv.getClass().getSimpleName());
            }
        }

        //return addVariable(v, "x" + v, 0, CAP, false);
        return addFreeVariable(v);
    }

    /**
     * Obtain a collection of the numeric variables identified
     * by the collection of inputs.
     */
    private Collection<String> getNumeric(Collection<Integer> inputs){
        return inputs.stream()
                     .map(this :: getNumeric)
                     .collect(Collectors.toList());
    }

    /**
     * Introduces a new boolean variable.
     */
    private String addBoolVariable(int b){
        String var = "b" + b;

        if(!boolFS.containsKey(b)){
            declare("Bool", var);
            boolFS.put(b, var);
            // Relation with existent numeric counterpart
            if(numFS.containsKey(b))
                addAssertion(String.format("(= %s (not (= %s 0)))", var, numFS.get(b)));
        }else var = boolFS.get(b);

        return var;
    }

    /**
     * Obtain the boolean variable with the given label.
     * If there is none, a new boolean variable will be created,
     * whose value depends on the value of the numeric variable
     * with the same label, if it exists.
     */
    private String getFormula(int b){
        if(!boolFS.containsKey(b) && binaryValues.containsKey(b)){
            BooleanValue bool = binaryValues.get(b).toBool();
            ((BooleanFormula) bool).accept(this, null); // TODO arg
        }
        return addBoolVariable(b);
    }

    /**
     * Determine the collection of boolean variables corresponding
     * to the given labels.
     */
    private Collection<String> getFormula(Collection<Integer> inputs){
        return inputs.stream()
                     .map(this :: getFormula)
                     .collect(Collectors.toList());
    }

    /**
     * Defines the comparison between a numeric variable and a constant numeric value.
     */
    protected String range(String comparator, String var, int value){
        return String.format("(%s %s %d)", comparator, var, value);
    }

    /**
     * Specifies an N-ary gate which can either be an AritGate or MultiGate.
     * Assumes that at least two inputs are provided (guaranteed by
     * AritGate and MultiGate definition).
     *
     * @param gate label
     * @param op Gate operation (and/or if MultiGate ; +,-, / or *  if AritGate)
     * @param inputs identifiers of the inputs of the gate
     * @param isArit true -> AritGate ; false -> MultiGate
     */
    private void nAry(int gate, String op, Collection<Integer> inputs, boolean isArit){
        String var = isArit ? addFreeVariable(gate) : addBoolVariable(gate);
        Collection<String> vars  = isArit ? getNumeric(inputs) : getFormula(inputs);

        addAssertion(
                String.format(
                    "(= %s (%s %s))",
                    var, op, String.join(" ", vars)
                )
            );
    }

    /**
     * Adds the AND/OR gate constraints to the assertion stack.
     * @param multigate AND or OR gate
     * @param arg null
     * @return Gate identifier
     */
    @Override
    public Integer visit(MultiGate multigate, Object arg) {
        final int gate = multigate.label();
        if (visitedBV.add(gate)) {
            List<Integer> is = new ArrayList<>();
            multigate.forEach(input -> is.add(input.accept(this, arg)));

            nAry(gate, multigate.op() == AND ? "and" : "or", is, false);
        }
        return gate;
    }

    /**
     * Specifies an ITEGate over boolean or numeric values.
     * @param gate ITEGate identifier
     * @param i condition identifier
     * @param t value if true
     * @param e value if false
     * @param qt false -> t/e are BooleanValues; true -> t/e are NumericValues
     */
    private String ite(int gate, int i, int t, int e, boolean qt){
        String var = addBoolVariable(gate);

        String if_expr = getFormula(i);
        String then_expr = qt ? getNumeric(t) : getFormula(t);

        String iteExpr = t != e ?
            String.format("(ite %s %s %s)", if_expr, then_expr, qt ? getNumeric(e) : getFormula(e)) :
            then_expr;

        return String.format("(= %s %s)", var, iteExpr);
    }

    /**
     * Adds the ITE constraint to the assertion stack.
     * @param itegate ITE or IMPLICATION
     * @param arg null
     * @return ITE identifier
     */
    @Override
    public Integer visit(ITEGate itegate, Object arg) {
        final int gate = itegate.label();
        if (visitedBV.add(gate)) {
            final int i = itegate.input(0).accept(this, arg);
            final int t = itegate.input(1).accept(this, arg);
            final int e = itegate.input(2).accept(this, arg);
            addAssertion(ite(gate, i, t, e, false));
        }
        return gate;
    }

    /**
     * Negation of the input at hand.
     * @param negation not gate
     * @param arg null
     * @return NOT identifier
     */
    @Override
    public Integer visit(NotGate negation, Object arg) {
        int gate = negation.label();
        if(visitedBV.add(gate)){
            int i = negation.input(0).accept(this, arg);
            addAssertion(String.format("(= %s (not %s))", addBoolVariable(gate), getFormula(i)));
        }
        return gate;
    }

    /**
     * Adds the new boolean variable to the assertion stack.
     * @param variable in question
     * @param arg null
     * @return Variable identifier
     */
    @Override
    public Integer visit(BooleanVariable variable, Object arg) {
        int l = variable.label();
        if(visitedBV.add(l)) {
            addBoolVariable(l);
        }
        return l;
    }

    /**
     * @return The syntax of the cvc4 operator associated with {@code op},
     * with respect to the logic at hand.
     */
    protected String cvc4Operator(Operator op){
        return op == DIV && this.type.equals("Int") ? "div" : op.toString();
    }

    /**
     * Helper method to chain the same binary arithmetic operation over the specified inputs.
     * It is assumed that least two inputs are given.
     *
     * @param op arithmetic operator
     * @param inputs labels of the numeric fs serving as input
     * @requires inputs.size() > 1
     * @return let [i1, i2, ..] = inputs | ... (op (op (op i1 i2) i3) i4) ...
     */
    protected String chainOperator(String op, Collection<Integer> inputs){
        StringBuilder chain = new StringBuilder();
        int Nc = inputs.size() -1 ;

        // (op (op (op ...
        for(int i = 0; i < Nc; i++){
            chain.append("(").append(op).append(" ");
        }

        Iterator<String> it = getNumeric(inputs).iterator();
        // First op: (op i1
        chain.append(it.next()).append(" ");

        // i2) i3) i4) ... in)
        //for(int i = 0; i < Nc && it.hasNext(); i++){
        while(it.hasNext()){
            String d = it.next();
            chain.append(" ").append(d).append(")");
        }

        return chain.toString();
    }

    /**
     * Adds the arithmetic gate constraints to the assertion stack.
     * @param aritgate PLUS, TIMES, MINUS, DIV or MOD gate
     * @param arg null
     * @return Gate identifier
     */
    @Override
    public Integer visit(AritGate aritgate, Object arg) {
        final int gate = aritgate.label();

        if (visited.add(gate)) {
            List<Integer> is = new ArrayList<>();
            aritgate.forEach(input -> is.add(input.accept(this, arg)));

            Operator op = aritgate.op();

            /*if(op == MINUS){
                String minus = String.format(
                    "(- %s)", is.stream().map(this :: getNumeric).collect(Collectors.joining(" "))
                );

                addAssertion(String.format(
                    "(= %s (ite (> %s 0) %s 0))", 
                    addFreeVariable(gate), minus, minus
                ));
            }
            else*/ if(op == MOD || op == DIV){
                addAssertion(String.format("(= %s %s)", addFreeVariable(gate), chainOperator(cvc4Operator(op), is)));
            }else nAry(gate, cvc4Operator(op), is, true);
        }

        return gate;
    }

    /**
     * Adds the choice gate constraints to the assertion stack.
     * @param choicegate MIN, MAX or ITE gate
     * @param arg null
     * @return Gate identifier
     */
    @Override
    public Integer visit(ChoiceGate choicegate, Object arg) {
        final int gate = choicegate.label();
        if (visited.add(gate)) {
            String x = getNumeric(choicegate.input(0).accept(this, arg));
            String y = getNumeric(choicegate.input(1).accept(this, arg));

            String condition = 
                choicegate.op() == MIN ? String.format("(< %s %s)", x, y) :
                choicegate.op() == MAX ? String.format("(> %s %s)", x, y) :
                getFormula(((kodkod.engine.num.ITEGate)choicegate).getCondition().accept(this, arg));

            addAssertion(String.format(
                "(= %s (ite %s %s %s))", addFreeVariable(gate), condition, x, y
            ));

        }
        return gate;
    }

    /**
     * Adds the unary gate constraints to the assertion stack.
     * @param unarygate NEG, ABS or SGN gate
     * @param arg null
     * @return Gate identifier
     */
    @Override
    public Integer visit(UnaryGate unarygate, Object arg) {
        final int gate = unarygate.label();
        if (visited.add(gate)) {

            final String i = getNumeric(unarygate.input().accept(this, arg));
            final String u = addFreeVariable(gate);

            if(unarygate.op() == NEG) addAssertion(String.format("(= %s (- %s))", u, i));
            else if(unarygate.op() == ABS) addAssertion(String.format("(= %s  (abs %s))", u, i));
            else{
                //op == SGN
                addAssertion(String.format("(= %s (ite (> %s 0) 1 (ite (< %s 0) -1 0)))", u, i, i));
            }
        }
        return gate;
    }

    /**
     * Adds the comparison gate constraints to the assertion stack.
     * @param cmpgate =, >, <, >= or <= gate
     * @param arg null
     * @return Gate identifier
     */
    @Override
    public Integer visit(CmpGate cmpgate, Object arg) {
        final int gate = cmpgate.label();
        if (visitedBV.add(gate)) {
            addAssertion(String.format("(= %s (%s %s %s))",
                    addBoolVariable(gate),
                    cmpgate.op().toString(),
                    getNumeric(cmpgate.inputNum(0).accept(this, arg)),
                    getNumeric(cmpgate.inputNum(1).accept(this, arg))
            ));
        }
        return gate;
    }

    /**
     * Adds the quantitative NOT gate constraints to the assertion stack.
     * @param notg numeric not gate
     * @param arg null
     * @return Gate identifier
     */
    @Override
    public Integer visit(NumNotGate notg, Object arg) {
        final int gate = notg.label();
        if (visitedBV.add(gate)) {
            final int n = notg.input().accept(this, arg);
            String notExp = binaryValues.containsKey(n) ? getFormula(n) : "(not (= " + getNumeric(n) + " 0))";
            addAssertion(String.format("(= %s (not %s))", addBoolVariable(gate), notExp));
        }
        return gate;
    }

    /**
     * Helper method to determine the lowest maximum value that a given variable can assume,
     * between the given value and the maximum value imposed by the solver.
     * @param maxValue given value
     * @return null => CAP == null && maxValue == null
     *         else maxValue < CAP ? maxValue : CAP
     */
    private Integer getLimit(Integer maxValue){
        if(CAP == null)
            return maxValue;
        if(maxValue == null)
            return CAP;

        return maxValue < CAP ? maxValue : CAP;
    }

    /**
     * Adds the new variable to the assertion stack.
     * @param variable numeric variable
     * @param arg null
     * @return Gate identifier
     */
    @Override
    public Integer visit(NumericVariable variable, Object arg) {
        int l = variable.label();
        if(visited.add(l)){
            NumericConstant maxVal = variable.getMaximumValue();
            Integer limit = getLimit(maxVal == null ? null : maxVal.getValue().intValue());

            List<NumericValue> admissibleValues = variable.getPotentialValues();
            if(admissibleValues != null && admissibleValues.size() > 0){
                String v = addVariable(l, "a" + l, null, null, true);

                // Possible values
                if(admissibleValues.size() == 1)
                    addAssertion(String.format("(= %s %s)", v, getNumeric(admissibleValues.get(0).accept(this, arg))));
                else addAssertion(String.format("(or %s)",
                        admissibleValues.stream()
                                        .map(x -> String.format("(= %s %s)", v, getNumeric(x.accept(this, arg))))
                                        .collect(Collectors.joining(" "))));

                // Impose the limit
                if(limit != null) addAssertion(range("<=", v, limit));
            }
            else if(variable.isTrue()){
                String v = addVariable(l, "s" + l, null, limit, true);
                addAssertion("(not (= " + v + " 0))");
            }
            else if(variable.isFalse()){
                numFS.put(l, "0");
            }
            else addVariable(l, "x" + l, null, limit, true);
        }
        return l;
    }

    /**
     * Stores the binary value provided for future reference, once either or both its Boolean and Numeric
     * counterparts are required to define the specification.
     * @param b binary value
     * @param arg null
     * @return binary value identifier
     */
    @Override
    public Integer visit(BinaryValue b, Object arg){
        int l = b.label();
        if(!binaryValues.containsKey(l))
            binaryValues.put(l, b);
        return l;
    }

    /**
     * Adds the reference to a numeric constant on the assertion stack.
     * @param constant numeric constant
     * @param arg null
     * @return Gate identifier
     */
    @Override
    public Integer visit(NumericConstant constant, Object arg) {
        int l = constant.label();
        if(visited.add(l) && !numFS.containsKey(l)) {
            if(this.type.equals("Int")) {
                int c = constant.getValue().intValue();
                numFS.put(l, c >= 0 ? Integer.toString(c) : "(- " + -c + ")");
            }
            else{ // Real
                double c = constant.getValue().doubleValue();
                numFS.put(l, c >= 0 ? Double.toString(c) : "(- " + -c + ")");
            }
        }
        return l;
    }
}